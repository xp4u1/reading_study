# Seminarfach Auswertung

```elixir
Mix.install([
  {:explorer, "~> 0.7.1"},
  {:kino_explorer, "~> 0.1.11"},
  {:kino_db, "~> 0.2.4"},
  {:postgrex, "~> 0.17.3"},
  {:kino_vega_lite, "~> 0.1.10"}
])
```

## Initialisierung und Datenimport

Für die Verbindung zur Supabase-Datenbank muss das Passwort in den Livebook-Secrets als `SUPABASE_PASSWORD` hinterlegt werden.

<!-- livebook:{"attrs":{"database":"postgres","hostname":"db.jatklaoradygtxkxlfwh.supabase.co","password_secret":"SUPABASE_PASSWORD","port":5432,"type":"postgres","use_ipv6":false,"use_ssl":false,"username":"postgres","variable":"conn"},"chunks":null,"kind":"Elixir.KinoDB.ConnectionCell","livebook_object":"smart_cell"} -->

```elixir
opts = [
  hostname: "db.jatklaoradygtxkxlfwh.supabase.co",
  port: 5432,
  username: "postgres",
  password: System.fetch_env!("LB_SUPABASE_PASSWORD"),
  database: "postgres"
]

{:ok, conn} = Kino.start_child({Postgrex, opts})
```

```elixir
alias Explorer.DataFrame, as: DF
require Explorer.DataFrame
```

Alle Einträge mit dem Datentyp `uuid` können nicht von Livebook eingelesen werden. Deshalb muss man sie vorher zu `text` umwandeln.

<!-- livebook:{"attrs":{"cache_query":true,"connection":{"type":"postgres","variable":"conn"},"data_frame_alias":"Elixir.DF","query":"select\n  users.id::text,\n  users.fingerprint,\n  users.test,\n  questions_lehrerin.gefuehle_beruf as fragen_gefuehle_beruf,\n  questions_lehrerin.warum_lehrer as fragen_warum_lehrer,\n  questions_lehrerin.oeffentlichkeit_meinung as fragen_oeffentlichkeit_meinung,\n  questions_lehrerin.vorwurf_eltern as fragen_vorwurf_eltern,\n  questions_lehrerin.internet as fragen_internet,\n  evaluation_bionic.schneller as bionic_schneller,\n  evaluation_bionic.leichter as bionic_leichter,\n  evaluation_bionic.textverstaendnis as bionic_textverstaendnis,\n  evaluation_bionic.woerter_finden as bionic_woerter_finden,\n  evaluation_bionic.mehr_texte as bionic_mehr_texte,\n  evaluation_bionic.in_schule as bionic_in_schule,\n  evaluation_bionic.anmerkungen as bionic_anmerkungen,\n  evaluation_personal.freude_lesen as persoenlich_freude_lesen,\n  evaluation_personal.haeufigkeit_lesen as persoenlich_haeufigkeit_lesen,\n  evaluation_personal.ziel_lesen as persoenlich_ziel_lesen,\n  evaluation_personal.textverstaendnis as persoenlich_textverstaendnis,\n  evaluation_personal.alter as persoenlich_alter\nfrom\n  users\n  full join evaluation_bionic on users.id = evaluation_bionic.user_id\n  full join evaluation_personal on users.id = evaluation_personal.user_id\n  full join questions_lehrerin on users.id = questions_lehrerin.user_id\n","result_variable":"postgres_data","timeout":null},"chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
postgres_data =
  Postgrex.query!(
    conn,
    """
    select
      users.id::text,
      users.fingerprint,
      users.test,
      questions_lehrerin.gefuehle_beruf as fragen_gefuehle_beruf,
      questions_lehrerin.warum_lehrer as fragen_warum_lehrer,
      questions_lehrerin.oeffentlichkeit_meinung as fragen_oeffentlichkeit_meinung,
      questions_lehrerin.vorwurf_eltern as fragen_vorwurf_eltern,
      questions_lehrerin.internet as fragen_internet,
      evaluation_bionic.schneller as bionic_schneller,
      evaluation_bionic.leichter as bionic_leichter,
      evaluation_bionic.textverstaendnis as bionic_textverstaendnis,
      evaluation_bionic.woerter_finden as bionic_woerter_finden,
      evaluation_bionic.mehr_texte as bionic_mehr_texte,
      evaluation_bionic.in_schule as bionic_in_schule,
      evaluation_bionic.anmerkungen as bionic_anmerkungen,
      evaluation_personal.freude_lesen as persoenlich_freude_lesen,
      evaluation_personal.haeufigkeit_lesen as persoenlich_haeufigkeit_lesen,
      evaluation_personal.ziel_lesen as persoenlich_ziel_lesen,
      evaluation_personal.textverstaendnis as persoenlich_textverstaendnis,
      evaluation_personal.alter as persoenlich_alter
    from
      users
      full join evaluation_bionic on users.id = evaluation_bionic.user_id
      full join evaluation_personal on users.id = evaluation_personal.user_id
      full join questions_lehrerin on users.id = questions_lehrerin.user_id

    """,
    []
  )
```

## Doppelte Einträge entfernen

Doppelte Einträge finden:

```elixir
duplicate_uuids =
  postgres_data.rows
  |> Enum.frequencies_by(fn entry ->
    Enum.at(entry, 0)
  end)
  |> Map.reject(fn {_key, value} -> value == 1 end)
  |> Map.keys()
```

Es ist nicht schlimm, wenn doppelte Einträge gelöscht werden. Aber hier sind alle Einträge mit gleicher `user_id`, die unterschiedliche Daten enthalten:

```elixir
duplicate_uuids
|> Enum.map(fn uuid ->
  postgres_data.rows
  |> Enum.filter(&(Enum.at(&1, 0) == uuid))
end)
|> Enum.map(&Enum.uniq/1)
|> Enum.filter(&(Enum.count(&1) != 1))
```

Es werden alle doppelten Einträge mit `Enum.uniq_by` anhand ihrer `user_id` gelöscht.

```elixir
rows = Enum.uniq_by(postgres_data.rows, &Enum.at(&1, 0))

data =
  %Postgrex.Result{
    columns: postgres_data.columns,
    rows: rows,
    num_rows: Enum.count(rows)
  }
  |> DF.new()
```

## Tracking Daten

Die Tracking Daten können mit dem Go-Tool aus dem `data/tracking` Verzeichnis erzeugt werden. Der Output des Programms muss sich für die Auswertung in `data/export/tracking.csv` befinden.

```elixir
tracking_data =
  DF.from_csv!("./export/tracking.csv")
  |> DF.rename(user_id: "id")
```

```elixir
data = DF.join(data, tracking_data, how: :left)
```

<!-- livebook:{"branch_parent_index":2} -->

## Text

```elixir
answers = [1, 0, 2, 1, 0]

correct_questions_data =
  data
  |> DF.select(
    &(&1 == "test" || String.starts_with?(&1, "fragen") || String.starts_with?(&1, "reading") ||
        &1 == "questions_duration")
  )
  |> DF.to_rows()
  |> Enum.map(fn rows ->
    ~w[fragen_gefuehle_beruf fragen_warum_lehrer fragen_oeffentlichkeit_meinung fragen_vorwurf_eltern fragen_internet]
    |> Enum.with_index()
    |> Enum.map(fn {frage, index} ->
      %{
        test: rows["test"],
        question: frage,
        correct: rows[frage] == Enum.at(answers, index)
      }
    end)
  end)
  |> List.flatten()
  |> DF.new()
```

<!-- livebook:{"attrs":{"chart_title":"Answers","height":null,"layers":[{"active":true,"chart_type":"bar","color_field":"correct","color_field_aggregate":null,"color_field_bin":null,"color_field_scale_scheme":null,"color_field_type":"nominal","data_variable":"correct_questions_data","geodata_color":"blue","latitude_field":null,"longitude_field":null,"x_field":"question","x_field_aggregate":null,"x_field_bin":null,"x_field_scale_type":null,"x_field_type":"nominal","y_field":"__count__","y_field_aggregate":null,"y_field_bin":null,"y_field_scale_type":null,"y_field_type":null}],"vl_alias":"Elixir.VegaLite","width":300},"chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 300, title: "Answers")
|> VegaLite.data_from_values(correct_questions_data, only: ["question", "correct"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "question", type: :nominal)
|> VegaLite.encode(:y, aggregate: :count)
|> VegaLite.encode_field(:color, "correct", type: :nominal)
```

<!-- livebook:{"attrs":{"assign_to":"correct_questions_data_bionic","collect":true,"data_frame":"correct_questions_data","data_frame_alias":"Elixir.DF","is_data_frame":true,"lazy":true,"missing_require":null,"operations":[{"active":true,"column":"test","data_options":{"correct":"boolean","question":"string","test":"boolean"},"datalist":[],"filter":"equal","message":null,"operation_type":"filters","type":"boolean","value":"true"}]},"chunks":null,"kind":"Elixir.KinoExplorer.DataTransformCell","livebook_object":"smart_cell"} -->

```elixir
correct_questions_data_bionic =
  correct_questions_data |> DF.lazy() |> DF.filter(test == true) |> DF.collect()
```

<!-- livebook:{"attrs":{"assign_to":"correct_questions_data_reference","collect":true,"data_frame":"correct_questions_data","data_frame_alias":"Elixir.DF","is_data_frame":true,"lazy":true,"missing_require":null,"operations":[{"active":true,"column":"test","data_options":{"correct":"boolean","question":"string","test":"boolean"},"datalist":[],"filter":"equal","message":null,"operation_type":"filters","type":"boolean","value":"false"}]},"chunks":null,"kind":"Elixir.KinoExplorer.DataTransformCell","livebook_object":"smart_cell"} -->

```elixir
correct_questions_data_reference =
  correct_questions_data |> DF.lazy() |> DF.filter(test == false) |> DF.collect()
```

<!-- livebook:{"attrs":{"chart_title":"Answers Bionic","height":null,"layers":[{"active":true,"chart_type":"bar","color_field":"correct","color_field_aggregate":null,"color_field_bin":null,"color_field_scale_scheme":null,"color_field_type":"nominal","data_variable":"correct_questions_data_bionic","geodata_color":"blue","latitude_field":null,"longitude_field":null,"x_field":"question","x_field_aggregate":null,"x_field_bin":null,"x_field_scale_type":null,"x_field_type":"nominal","y_field":"__count__","y_field_aggregate":null,"y_field_bin":null,"y_field_scale_type":null,"y_field_type":null}],"vl_alias":"Elixir.VegaLite","width":300},"chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 300, title: "Answers Bionic")
|> VegaLite.data_from_values(correct_questions_data_bionic, only: ["question", "correct"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "question", type: :nominal)
|> VegaLite.encode(:y, aggregate: :count)
|> VegaLite.encode_field(:color, "correct", type: :nominal)
```

<!-- livebook:{"attrs":{"chart_title":"Answers Reference","height":null,"layers":[{"active":true,"chart_type":"bar","color_field":"correct","color_field_aggregate":null,"color_field_bin":null,"color_field_scale_scheme":null,"color_field_type":"nominal","data_variable":"correct_questions_data_reference","geodata_color":"blue","latitude_field":null,"longitude_field":null,"x_field":"question","x_field_aggregate":null,"x_field_bin":null,"x_field_scale_type":null,"x_field_type":"nominal","y_field":"__count__","y_field_aggregate":null,"y_field_bin":null,"y_field_scale_type":null,"y_field_type":null}],"vl_alias":"Elixir.VegaLite","width":300},"chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 300, title: "Answers Reference")
|> VegaLite.data_from_values(correct_questions_data_reference,
  only: ["question", "correct"]
)
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "question", type: :nominal)
|> VegaLite.encode(:y, aggregate: :count)
|> VegaLite.encode_field(:color, "correct", type: :nominal)
```

<!-- livebook:{"offset":14089,"stamp":{"token":"XCP.QXlkfbxyAO6e9NznyJbP9HJkxPISakUAqixLutvpC0SrKJPqrSPS-ME6S28hG_OR0-nr44XrSzmrAL4gu6oTjut1XAjJilRPxqjEUixmHt9He8UWLnY_My_Z9CI","version":2}} -->
